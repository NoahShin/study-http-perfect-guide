# 내용 협상이 무엇이냐

예를 들어 우리 사이트의 주 고객이 영어 사용자와 프랑스어 사용자 양측이 존재한다면, 우리는 사용자에 맞게 콘텐츠를 제공해줘야 한다. 

HTTP는 이런 판단이 가능하게 내용협상이란 방법을 제공한다.

이 방법은 하나의 URL이 여러 가지 리소스 중 적합한 것을 제공하도록 할 수 있다. 여기서는 서로 다른 버전을 배리언트( Variant ) 라고 부른다


# 요약 테이블
![](https://images.velog.io/images/noahshin__11/post/ca865eb1-61e3-4953-bb6e-ccf76ca7f333/image.png)

# 클라이언트 주도 협상
서버가 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어

클라이언트가 보고 싶은 것을 선택하게 하는 방법입니다.

장점: 서버 입장에서 구현하기 가장 쉬운 방법으로, 최선의 사본이 선택됩니다.

단점: 각 페이지에 두 번의 요청(목록 요청, 선택한 사본 요청)이 필요해 시간이 오래 걸립니다.

→ 클라이언트의 입장에서 화를 유발할 수 있습니다.

# 서버 주도 협상
클라이언트 주도 협상에는 위와 같이 커뮤니케이션 관련 단점이 존재했습니다.

서버 주도 협상은 서버가 어떤 페이지를 돌려줄 것인지 결정해서 이러한 단점을 보완하고자 했습니다. 대신, 서버가 선택할 수 있게끔 클라이언트는 무엇을 선호하는지에 대한 정보를 서버에게 제공하는데, 아래의 두 가지 메커니즘을 사용합니다.

내용 협상 헤더: 내용 협상 헤더들을 살펴보고, 서버는 클라이언트의 Accept 관련 헤더들을 확인 후 알맞은 응답 헤더를 준비
내용 협상 헤더 외의 다른 헤더를 살펴보고, (예- User-Agent 헤더 기반) 응답을 준비

![](https://images.velog.io/images/noahshin__11/post/552bad74-19d4-4a94-9ebf-aac0be77613e/image.png)

# 투명 협상
투명 협상은 중간에 프락시를 두면서 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거한다.

프락시는 클라이언트의 기대를 파악하고, 클라이언트와 협상할 수 있는 능력이 있다고 간주되는데, 서버는 프락시에게 Vary 헤더를 통해 어떤 조건을 확인해야 하는지를 알려줄 수 있다.


 
캐시 프락시가 만일 서버의 의사결정 프로세스를 알게 된다면, 캐시는 서버의 입장에서 협상을 진행할 수도 있다.

### 캐시와 얼터네이트 ( alternate )
캐시는 클라이언트에게 올바른 응답을 주기 위해 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당부분을 그대로 사용해야 한다.

캐시는 똑같은 리소스에 대하여 다른 버전을 동시에 가질 수 있도록, 이번의 응답과 저번의 응답을 모두 저장한다.

![](https://images.velog.io/images/noahshin__11/post/2420f326-075f-47d7-90f4-d7156a8b2a38/image.png)

### Vary 헤더
제공된 문서가 의존하고 있는 헤더를 포함하여 돌려준다.

캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다. 캐시가 검색을 할 때 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고, 요청의 배리언트를 캐시된 배리언트와 맞춰본다.

맞는 것이 없다면 서버에서 가져온다.

- http Vary 응답 헤더는
서버가 문서를 선택하거나, 커스텀 콘텐츠를 생성할 때 고려한
클라 요청 헤더 모두를 나열한다.

- 새 요청이 도착했을 때, 캐시는 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다.

- 캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인하고,
Vary 헤더가 명시하고 있는 헤더들은
새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 한다.
- 서버는 클라의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에
투명 협상을 구현하기 위해 캐시는 반드시
캐시된 variant와 함께
클라 요청 헤더와
그에 알맞은 서버 응답헤더 양쪽 모두를 저장해야한다.


- 서버의 Vary 헤더가 이렇다면, 거대한 수의 다른 User-Agent와 Cookie이 많은 배리언트 variant를 만들어낼 것이다.
- 캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다.
- 캐시가 검색을 할 때,
1. 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고
2. 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본다.
3. 만약 맞는 것이 없으면, 캐시는 문서를 서버에서 가져온다.
맞는 것이 있다면, 해당 콘텐츠를 보내준다.
![](https://images.velog.io/images/noahshin__11/post/2654af0a-9952-41dc-8720-fff22a6f1c4f/image.png)

![](https://images.velog.io/images/noahshin__11/post/06bda1a9-41c7-4cce-89dc-b3601acd6504/image.png)
![](https://images.velog.io/images/noahshin__11/post/8ae309a7-1213-4924-b8fd-0adfd0614157/image.png)

# 트랜스 코딩

## 무엇?

- 서버가 클라이언트의 요구에 맞는 문서를 하나도 갖고 있지 않다면, 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환하는 옵션

- 포맷 변환
- 정보 합성
- 내용 주입

![](https://images.velog.io/images/noahshin__11/post/7cf7929f-8bc8-4cc6-8c29-6b87eab5d567/image.png)

## 포맷 변환
- 데이터를 클라이언트가 다른 환경에서도 볼수 있도록 포맷 변환 시켜주는 것
- 내용 협상 헤더에 의해 주도된다ㅣ. (user-agent header에 의해서 주도될 수도 있다)
- 내용 변환 & 트랜스 코딩 = 콘텐츠를 특정 접근 장치에서 볼 수 있도록 하기 위한
- 콘텐츠 인코딩 & 전송 인코딩 = 콘텐츠를 더 효율적이거나 안전한 전송을 위한

## 정보 합성

- 보통 포털 사이트의 웹페이지 디렉터리와 같은 자동화된 웹페이지 분류 시스템에 의해 종종 사용된다.

## 내용 주입

이제까지는 다 뭔가 줄이는 거였는데 이거는 오히려 양을 늘리는 편

지나가는 HTML 페이지에 자동으로 광고 삽입이나 특정 사용자를 대상으로 하는 광고를 그때 그때 효과적으로 삽입하기 위해 동적으로 이루어 진다. (광고 알고리즘...?)

![](https://images.velog.io/images/noahshin__11/post/4239182e-9f73-4366-897d-e269c7b6bb79/image.png)


## 트랜스코딩 vs 정적으로 미리 생성해 놓기

- 트랜스코딩의 대안은 웹서버에 여러가지 사본을 만드는 것
근데 이 방식은 페이지에 대한 어떠한 작은 변화도 여러 페이지의 수정을 요구하고
각 페이지의 모든 버전을 저장하기 위해 많은 공간이 필요

광고 삽입과 같은 몇몇 트랜스 코딩은 정적인 방법으로는 수행할 수 없는데, 이는 페이지를 요청한 사용자에게 달려 있기 때문.